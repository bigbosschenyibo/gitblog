# [补数的引入](https://github.com/bigbosschenyibo/gitblog/issues/2)

> 补数是为了解决+0和-0在计算机中表示不唯一的问题而引入的；

### 机器数 真值
一个数在机内的表达形式被称为"机器数"，而它代表的数值称为此机器数的"真值"
一个数在计算机内是采用二进制编码表示的，数有正负之分，如何在计算机中表示符号?
0 表示正 1 表示负，符号位放在最高位。
例如8位二进制数 A =(+1011011) 在机器中可以表示为 01011011
B=(-1011011)在机器中可以表示为11011011
最左边代表符号位和数字本身一起作为一个数
符号数字化之后计算机可以方便地识别和表示数字符号了。
为了改进符号数的运算和简化运算其的硬件结构，人们研究了符号数的多种二进制编码方法，其本质上都是对负数表示的不同编码
### 原码
符号 与 数的绝对值 一起编码称为 原码
如 X=+0101011 [X]原=00101011
X=-0101011 [X]原=10101011
这里[X]原 被称为机器数 X被称为机器数的真值
X=-0.1011 [X]原=1.1011
X=+0.1011 [X]原=0.1011
采用原码表示法好处是简单直观，与指针转换方便，但缺点是 零的表示不唯一 ，因为：
[+0]原=0 000 0000
[-0]原= 1 000 0000
![零具有二义性](https://github.com/user-attachments/assets/a9ae9a2a-ef2c-4bcc-bfff-c4dfe1a48867)

### 补码
模数的概念：
模数从物意义上来讲，是某种计量容器。例如：钟表，模数是12。钟表计时方式是 到达12就从零开始(扔掉一个12)，这在数学上是 取模(取余) 运算(mod)。
在C++中%是除法求余数的算术运算符。 如 14%12 = 2。
如果现在准确的时间是6点整 而你的手表是8点整，那么如何才能将时间调整到6点整呢？向后拨2小时，或向前拨10小时。效果是一样的，即：
8-2=6
(8+10)%12=6
故在模数系统中 8-2 = 8+10 (mod 12)
上式成立 是因为 2与10对模数12是互为补数的。(2+10=12)
![模数系统](https://github.com/user-attachments/assets/d2afafe9-e1e9-40b5-bbfa-7a98fb377f6d)

![补数的引入](https://github.com/user-attachments/assets/92db8b02-70f5-4df1-814f-ee84d3430130)

![由原码求补码](https://github.com/user-attachments/assets/ff23436b-5e1b-488d-82b5-d9dd32298185)

> 对于负整数求补码快捷方式：用模减去这个数的绝对值  得到的就是补数

如 -1 的8位二进制补码 2的8次方 减去 1 = 255 255的二进制编码即 八个一 1111 1111
如 -0 的8位二进制补码 256-0=256 二进制编码即 1后面八个0 -- 1 0000 0000 因为要八位2进制 故补码为
0000 0000
如 -128的8位二进制补码 256-128=128 二进制编码即 1后面七个0 1000 0000